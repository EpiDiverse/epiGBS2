---
title: "epiGBS report"
#code-author: FleurGabru
#date: 11-07-2019
output:
  html_document:
    df_print: paged
params:
  rmd: "report.Rmd"
  d: !r Sys.Date()
  u: !r Sys.info()['user']
  dir: dir
---

#### author: `r params$u`

#### date: `r params$d`

```{r setup, include=FALSE}
chooseCRANmirror(graphics=FALSE, ind=33)
usePackage <- function(p)
{
  if (!is.element(p, installed.packages()[,1]))
    install.packages(p, dep = TRUE)
  require(p, character.only = TRUE)
}
usePackage("ggplot2")
usePackage("ggpubr")
usePackage("viridis")
usePackage("plyr")
usePackage("gplots")
usePackage("vcfR")
usePackage("reshape2")
usePackage("knitr")
usePackage("reticulate")

options(stringsAsFactors = FALSE)

knitr::opts_chunk$set(echo = FALSE)
knitr::knit_engines$set(python = reticulate::eng_python)
options(tinytex.verbose = TRUE)

Sys.setenv(dir=params$dir)
path <- params$dir
```

This report contains all important information about your epiGBS analysis. The ouput of this analysis is stored in ``r params$dir``. This report will give you a quick overview of the quality of your results. For more details please always refer to the original (log)files:

File | path
-----|-----
bedfile | ``r params$dir`/mapping/methylation.bed`
snpfile | ``r params$dir`/mapping/snp.vcf.gz`
multiQC-report | ``r params$dir`/multiQC_report.html`
demultiplexing-log | ``r params$dir`/output_demultiplex/demultiplex.log`
stacks-log | ``r params$dir`/output_demultiplex/clone-stacks/process_radtags.clone.log`
trimming-log | ``r params$dir`/trimmed/{Watson,Crick}_{R1,R2}.fq.gz_trimming_report.txt`
mapping-log | ``r params$dir`/mapping/mapping_variantcalling.log`


# Tabset {.tabset .tabset-fade .tabset-pills}

## Clones Removal
The PCR clones are removed from the raw sequencing reads using a random nucleotide sequence ("wobble") in the adapters.

Before removal, your raw reads contained `r system(paste0("cat ",params$dir,"/output_demultiplex/demultiplex.log | grep -v '^  Processing' | grep '% clone reads' | cut -f 3 -d ','"), intern=TRUE)`

The histogram shows how many read sequences you find with a specific number of PCR clones. Ideally, most will occure once "1" only.

```{r fig.cap="Fig. 1: Distribution of clone numbers"}
clone.stats <- system(paste0("cat ",params$dir,"/output_demultiplex/demultiplex.log | awk '/Num/,/^$/'"), intern=TRUE)
clone.stats <- strsplit(clone.stats, "\t")
clone.stats.df <- do.call(rbind, clone.stats)
colnames(clone.stats.df) <- c("Clones", "count")
clone.stats.df <- clone.stats.df[-1, ]
class(clone.stats.df) <- "numeric"
clone.stats.df <- as.data.frame(clone.stats.df)
breaks <- clone.stats.df[,1]
p.clone <- ggplot(clone.stats.df, aes(x=Clones, y=count)) +
  geom_bar(stat="identity", colour="black", lwd=0.5) +
  scale_y_continuous(trans='log2', name = "log2(count)") +
  scale_x_continuous(trans='log2', name = "log2(number of clones)", labels=breaks, breaks=breaks) +
  xlab("Clones") +
  scale_color_viridis(discrete=FALSE, option="C") +
  scale_fill_viridis(discrete=FALSE, option="C") +
  theme_pubr()
p.clone
```

## Demultiplexing

You performed demultiplexing with the process_reads program from stacks. The following stats table will give you information about how many reads were retained after barcode- and RAD-tag (RE cut site) check. For both 1 mismatch is allowed. Check your barcode or your enzyme information if the amount of retained reads is suprisingly low.

```{bash capture="demultiplexing stats"}
cat $dir/output_demultiplex/demultiplex.log | awk '/total sequences/,/^$/'
```

In a well designed study, read numbers per sample should be similar. You can check in the following histogram, if this is true for your current analysis:

```{r fig.cap="Fig.2: Histogram of the number of demultiplexed reads per read file"}
demult.table <- system(paste0("cat ",params$dir,"/output_demultiplex/clone-stacks/process_radtags.clone.log | awk '/^Barcode\tFilename\tTotal\tNoRadTag\tLowQuality\tRetained/,/^$/'"), intern = TRUE)
demult.table <- strsplit(demult.table, "\t")
demult.table.df <- do.call(rbind, demult.table)
colnames(demult.table.df) <- demult.table.df[1, ]
demult.table.df <- demult.table.df[-1, ]
class(demult.table.df[,3:6]) <- "numeric"

demult.table.ret.tot <- rbind(data.frame(demult.table.df[, -c(1,2)], label="Retained"), data.frame(demult.table.df[, -c(1,2)], label="Total"))
demult.table.ret.tot$counts <- c(demult.table.df[,6], demult.table.df[,3])
class(demult.table.ret.tot$counts) <- "numeric"
demult.mu.ret.tot <- ddply(demult.table.ret.tot, "label", summarise, grp.mean=mean(counts))

p.demult.ret.tot <- ggplot(demult.table.ret.tot, aes(x=counts, color=label, fill=label)) +
  geom_histogram(aes(y=..density..), position="identity", alpha=0.7, binwidth=10000)+
  geom_density(alpha=0.2)+
  geom_vline(data=demult.mu.ret.tot, aes(xintercept=grp.mean, color=label),
             linetype="dashed")+
  scale_color_viridis(discrete=TRUE, option="C") +
  scale_fill_viridis(discrete=TRUE, option="C") +
  labs(x="Read Counts", y = "Density")+
  theme_pubr()
p.demult.ret.tot # ziet er stom uit, ook nadat ik met de binwidth heb gespeelt
```

Also check the multiQC stats for a full overview about the read quality. Please remember: Garbage in --> garbage out.

## Trimming

Adapter trimming of the demultiplexed reads is performed before proceeding with the mapping. The trimming software will validate read pairs and broken pairs will be removed. The table shows % of reads that contained adapters before trimming. To check whether trimming was succesfully executed, please refer to the multi-QC report.

File | %
-----|-----
Watson-R1 | `r system(paste0("cat ",params$dir,"/trimmed/Watson_R1.fq.gz_trimming_report.txt | grep 'Reads with adapters:' | awk 'NR>1 {print $1}' RS=\\( FS=\\)"), intern=TRUE)`
Watson-R2 | `r system(paste0("cat ",params$dir,"/trimmed/Watson_R2.fq.gz_trimming_report.txt | grep 'Reads with adapters:' | awk 'NR>1 {print $1}' RS=\\( FS=\\)"), intern=TRUE)`
Crick-R1 | `r system(paste0("cat ",params$dir,"/trimmed/Crick_R1.fq.gz_trimming_report.txt | grep 'Reads with adapters:' | awk 'NR>1 {print $1}' RS=\\( FS=\\)"), intern=TRUE)`
Crick-R2 | `r system(paste0("cat ",params$dir,"/trimmed/Crick_R2.fq.gz_trimming_report.txt | grep 'Reads with adapters:' | awk 'NR>1 {print $1}' RS=\\( FS=\\)"), intern=TRUE)`

## Mapping

To determine variants (SNPs or methylation), sequencing reads are mapped against the reference. Mapping is performed with STAR. A low mapping percentage might indicate low quality of the sequencing reads (e.g. 3' adapter sequences), a non-suitable reference or problems with the de novo sequence creation.

It follows the mapping stats:

Watson:
```{bash capture="mapping stats Watson-joined"}
cat $dir/mapping/mapping_variantcalling.log | awk '/watsonLog.final.out/,/% of reads unmapped: other/' | grep -E "(Uniquely mapped reads %|% of reads)" # gets mappings stats
```

Crick:
```{bash capture="mapping stats Crick-joined"}
cat $dir/mapping/mapping_variantcalling.log | awk '/crickLog.final.out/,/% of reads unmapped: other/' | grep -E "(Uniquely mapped reads %|% of reads)" # gets mappings stats
```

## SNP calling

The epiGBS pipeline performs SNP calling.
The SNP depth reflects the reliability of a called SNP and depends e.g. from the amount of reads and the mappibility of the reads.

```{r warning=FALSE, fig.cap= "Fig.3: Histogram of average SNP depth over all samples"}
vcf <- read.vcfR(paste0(params$dir,'/mapping/snp.vcf.gz'), verbose = FALSE)
dp <- extract.gt(vcf, element = "DP", as.numeric=TRUE)
```
In total, you have got `r nrow(dp)` SNPs.

The first figure plots the average SNP depth over all sample and shows it as a histogram.
```{r warning=FALSE, fig.cap= "Fig.3: Histogram of average SNP depth over all samples"}
depth.av <- data.frame(rowMeans(dp, na.rm = TRUE, dims = 1))
colnames(depth.av) <- "snp.depth"
depth.av$label <- "snp"
class(depth.av$snp.depth) <- "numeric"
depth.av.mu <- ddply(depth.av, "label", summarise, grp.mean=mean(snp.depth))

p.depth.av <- ggplot(depth.av, aes(x=snp.depth, color=label, fill=label)) +
  geom_histogram(aes(y=..density..), position="identity", alpha=0.7, binwidth=1)+
  geom_density(alpha=0.2)+
  geom_vline(data=depth.av.mu, aes(xintercept=grp.mean, color=label),
             linetype="dashed")+
  scale_color_viridis(discrete=TRUE, option="C") +
  scale_fill_viridis(discrete=TRUE, option="C") +
  labs(x="SNP Depth", y = "Density")+
  xlim(0, 50) +
  theme_pubr()
p.depth.av
```

The second plot(s) shows the SNP depth distribution for each sample.
```{r fig.cap="Fig.4: SNP depth distribution of each sample"}
dpf <- melt(dp, varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE)
dpf <- dpf[ dpf$Depth > 0,]

samps_per_row <- 24
myRows <- ceiling(length(levels(dpf$Sample))/samps_per_row) #calculates how many plot rows will be generated for the set row number
myList <- vector(mode = "list", length = myRows)

for(i in 1:myRows){
  myIndex <- c(i*samps_per_row - samps_per_row + 1):c(i*samps_per_row)
  myIndex <- myIndex[myIndex <= length(levels(dpf$Sample))]
  myLevels <- levels(dpf$Sample)[myIndex]
  myRegex <- paste(myLevels, collapse = "$|^")
  myRegex <- paste("^", myRegex, "$", sep = "")
  myList[[i]] <- dpf[grep(myRegex, dpf$Sample),]
  myList[[i]]$Sample <- factor(myList[[i]]$Sample)
}
myPlots <- vector(mode = "list", length = myRows)
for(i in 1:myRows){
  myPlots[[i]] <- ggplot(myList[[i]], aes(x=Sample, y=Depth)) +
    geom_violin(adjust=1.0, scale = "count", trim=TRUE)

  myPlots[[i]] <- myPlots[[i]] + theme_pubr()
  myPlots[[i]] <- myPlots[[i]] + theme(axis.title.x = element_blank(),
                                       axis.text.x = element_text(angle = 60, hjust = 1))
  myPlots[[i]] <- myPlots[[i]] + scale_y_continuous(trans=scales::log2_trans())
  myPlots[[i]] <- myPlots[[i]] + stat_summary(fun.data=mean_sdl, geom="pointrange", color="red", size = 0.25)

  print(myPlots[[i]])

}
```


## Methylation calling

This might be the part, you are interestd in the most. You probably will continue your statistical analysis with the methylation.bed file. Here you will find some simple summarized stats about the methylation calls.

```{python prep}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy
```

```{python read-meth}

df = pd.read_csv(
    f'{r.path}/mapping/methylation.bed',
    nrows=100000,
    sep='\t',
    na_values=['None']
)
```

The following histogram shows the distribution of the number of samples, in which the methylated positions were called.
```{python fig.cap="Fig.5: Distribution of the number of samples, that have a specific methylation site called"}
fig5, ax = plt.subplots(figsize=(7,7))
sns.distplot(pd.DataFrame({" samples": df['samples_called']}).dropna(), kde=False, rug=False)
plt.axvline(numpy.median(pd.DataFrame({" samples": df['samples_called']}).dropna()), color='grey', linestyle='--')
fig5
```

The next bar diagram shows, how many sites you obtained in each context CG, CHG, CHH.
```{python fig.cap="Fig. 6: Number of methylated sites in each context"}
fig6, ax1 = plt.subplots(1, figsize=(10,10))
sns.countplot(x="context", data=df)
fig6
```

```{python transform}
tidy = df.melt(id_vars=['chr', 'pos', 'context', 'samples_called'], var_name='sample', value_name = 'count')
tidy['kind'] = tidy['sample'].str.split('_').str[-1]
tidy['sample'] = tidy['sample'].str.split('_').str[:2].str.join('_')
data = tidy.groupby(['chr', 'pos', 'context', 'samples_called', 'sample', 'kind'])['count'].first().unstack().reset_index()
data['ratio'] = data['methylated'] / data['total']
```

The following diagram shows the distribution of the depth of all methylation sites in all samples.
```{python fig.cap="Fig.7: Distibution of the average depth per methylation site and sample"}
fig7, ax = plt.subplots(figsize=(7,7))
sns.distplot(pd.DataFrame({" total_count": data['total']}).dropna(), kde=False, rug=False)
plt.axvline(numpy.median(pd.DataFrame({" total_count": data['total']}).dropna()), color='grey', linestyle='--')
fig7
```

The following diagram shows the distribution of methylation ratio ("methylated"/"total") in different contexts (CG, CHG, CHH)
```{python fig.cap="Fig.8: Distribution of methylation ratio per context"}
fig8, (ax1, ax2, ax3) = plt.subplots(3, figsize=(10,10))
sns.distplot(pd.DataFrame({" ratio": data[data['context']== 'CG']['ratio']}).dropna(), color = 'brown', hist=True, kde=False, rug=False, ax=ax1).set_title('CG')
sns.distplot(pd.DataFrame({" ratio": data[data['context']== 'CHG']['ratio']}).dropna(), color = 'blue', hist=True, kde=False, rug=False, ax=ax2).set_title('CHG')
sns.distplot(pd.DataFrame({" ratio": data[data['context']== 'CHH']['ratio']}).dropna(), color = 'green', hist=True, kde=False, rug=False, ax=ax3).set_title('CHH')
fig8
```
